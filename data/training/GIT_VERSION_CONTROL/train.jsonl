{"messages": [{"role": "user", "content": "What's the difference between git merge and git rebase?"}, {"role": "assistant", "content": "git merge creates a merge commit combining two branches, preserves complete history, shows when branches diverged and merged. Creates diamond shape in git log --graph. Use when: working on public/shared branches, want to preserve exact history, collaborating with team. git rebase moves/replays commits from one branch onto another, rewrites history, creates linear history without merge commits. Use when: cleaning up local commits before pushing, want clean linear history, working on feature branch. Key difference: merge preserves history, rebase rewrites it. Golden rule: NEVER rebase commits already pushed to shared branches - will cause conflicts for others. Rebase private branches, merge public ones. Example: feature branch with 5 commits - rebase on main makes it look like developed on latest main, merge shows it branched from older commit."}]}
{"messages": [{"role": "user", "content": "How do I undo a commit that I already pushed?"}, {"role": "assistant", "content": "Options: 1) git revert - safest, creates new commit undoing changes: 'git revert HEAD && git push'. Preserves history, works on shared branches. 2) git reset + force push - dangerous: 'git reset --hard HEAD~1 && git push --force'. Rewrites history, breaks others' repos. ONLY for unshared branches. 3) Revert multiple commits: 'git revert HEAD~3..HEAD' reverts last 3 commits. 4) If just pushed: 'git reset --soft HEAD~1' to uncommit but keep changes, amend and push again. Best practice: use revert for public branches (safe, preserves history), reset only for private branches or immediate mistakes. If others pulled your commit, revert is only safe option. Force push should require team coordination and --force-with-lease flag to verify you're not overwriting others' work."}]}
{"messages": [{"role": "user", "content": "What's git reflog and how can it save me from mistakes?"}, {"role": "assistant", "content": "git reflog is safety net - records every HEAD movement (commits, checkouts, resets, rebases) for ~90 days. Unlike git log which shows commit history, reflog shows YOUR local history of HEAD changes. Use cases: 1) Recover deleted commits: 'git reset --hard HEAD~5' deleted commits, 'git reflog' shows them, 'git reset --hard HEAD@{1}' recovers. 2) Find lost branch: deleted branch, reflog shows last commit, 'git checkout -b recovered-branch commit-hash'. 3) Undo bad rebase: 'git reflog' find pre-rebase state, reset to it. 4) See what happened: trace your steps if confused. Commands: 'git reflog' shows history, 'git reflog show branch-name' for specific branch. Each entry has HEAD@{n} identifier. Reflog is LOCAL only - doesn't sync with remote. Expires after 90 days by default. Pro tip: 'git reflog --date=relative' shows when each action happened. Reflog saved me countless times from accidental hard resets!"}]}
{"messages": [{"role": "user", "content": "When should I use git stash and how does it work?"}, {"role": "assistant", "content": "git stash temporarily saves uncommitted changes, cleaning working directory. Use when: 1) Need to switch branches but have uncommitted work, 2) Pull from remote but have local changes, 3) Want to try something without committing current work, 4) Emergency bug fix on main while working on feature. Workflow: 'git stash' (or 'git stash push -m \"message\"') saves changes, 'git stash pop' applies and removes from stash, 'git stash apply' applies but keeps in stash. Multiple stashes: 'git stash list' shows all, 'git stash pop stash@{2}' applies specific one. Advanced: 'git stash -u' includes untracked files, 'git stash --patch' selective stashing. View stash contents: 'git stash show -p stash@{0}'. Drop stash: 'git stash drop stash@{0}'. Stash is local only. Gotcha: stash can have conflicts when applying - resolve like merge conflicts. Alternative: commit to temporary branch if stash feels hacky. Stash great for quick context switching!"}]}
{"messages": [{"role": "user", "content": "What's the best Git workflow for a team?"}, {"role": "assistant", "content": "Popular workflows: 1) GitHub Flow - simple, one main branch, feature branches, PRs for everything. Best for: continuous deployment, small teams, web apps. Workflow: branch from main → commit → open PR → review → merge → deploy. 2) GitFlow - complex, main+develop branches, feature/release/hotfix branches. Best for: scheduled releases, enterprise, multiple versions. Has release ceremony. 3) Trunk-based - everyone commits to main/trunk frequently, use feature flags for incomplete features. Best for: mature teams, CI/CD, high deployment frequency. Requires good tests. Choice depends on: team size (small=GitHub Flow, large=GitFlow), release cycle (continuous=Trunk, scheduled=GitFlow), team skill (beginners=GitHub Flow, advanced=Trunk). My recommendation: start with GitHub Flow - simple, proven, works for 80% of teams. Add complexity only if needed. Key practices regardless: protect main, require PR reviews, run CI on all branches, keep branches short-lived (<3 days), write good commit messages."}]}
{"messages": [{"role": "user", "content": "How do I write good commit messages?"}, {"role": "assistant", "content": "Good commit message format: Short subject line (<50 chars), blank line, detailed body (wrap at 72 chars). Subject: imperative mood ('Add feature' not 'Added' or 'Adds'), capitalize first letter, no period. Body: explain WHY not what (code shows what), include ticket numbers, mention breaking changes. Template: 'Verb object [ticket]\\n\\nWhy this change was needed\\nWhat problem it solves\\nAny side effects'. Good examples: 'Fix login crash on iOS 14 [JIRA-123]', 'Add password reset email [FEAT-456]\\n\\nUsers complained about no password recovery'. Bad: 'fix bug', 'WIP', 'update files', 'aaaaa'. Conventions: Conventional Commits pattern: 'feat:', 'fix:', 'docs:', 'refactor:', 'test:'. Git hooks can enforce format. Why it matters: helps reviewers, documents intent, makes git log useful, enables automated changelogs. Team should agree on convention. Tools: commitizen, commitlint enforce standards. Tip: if commit message is hard to write, commit might be doing too much - split it!"}]}
{"messages": [{"role": "user", "content": "What's the difference between git pull and git fetch?"}, {"role": "assistant", "content": "git fetch downloads commits/branches from remote but doesn't change your working directory. Just updates your local copy of remote branches (origin/main). Safe - can review before integrating. git pull = git fetch + git merge - downloads AND merges into current branch. Can cause merge conflicts. Workflow: 'git fetch origin' gets updates, 'git log origin/main' reviews them, 'git merge origin/main' or 'git rebase origin/main' integrates. vs 'git pull origin main' does everything at once. Best practice: use fetch for careful workflow, pull for quick updates on personal branches. Gotcha: 'git pull' might create merge commits - use 'git pull --rebase' for linear history. In shared branch workflows: fetch first, review changes, then merge. Prevents surprises. Advanced: 'git pull --ff-only' only succeeds if fast-forward possible, fails otherwise (safety). Personal preference: I use fetch+merge for clarity, pull for unimportant updates. Fetch never breaks your code, pull might."}]}
{"messages": [{"role": "user", "content": "How do I resolve merge conflicts?"}, {"role": "assistant", "content": "Conflict resolution steps: 1) 'git merge branch' fails with 'CONFLICT', 2) 'git status' shows conflicted files, 3) Open file - see markers: '<<<<< HEAD' (your changes), '=====' (separator), '>>>>> branch' (their changes), 4) Edit file - choose version or combine both, remove markers, 5) 'git add file' marks as resolved, 6) 'git commit' completes merge. Tools: 'git mergetool' opens visual diff tool (meld, kdiff3), IDEs have conflict resolvers. Complex conflicts: 'git diff --ours' shows your version, 'git diff --theirs' shows their version. Abort merge: 'git merge --abort' returns to pre-merge state. Prevent conflicts: small commits, pull frequently, communicate with team, use feature flags. Rebase conflicts: similar but 'git rebase --continue' after resolving, 'git rebase --abort' to cancel. Common mistake: forgetting to remove conflict markers - test after resolving! Pro tip: 'git rerere' (reuse recorded resolution) remembers how you resolved conflicts, auto-applies next time."}]}
{"messages": [{"role": "user", "content": "What's git cherry-pick and when should I use it?"}, {"role": "assistant", "content": "git cherry-pick applies specific commit from one branch to another without merging entire branch. Use cases: 1) Hotfix committed to wrong branch - cherry-pick to correct one, 2) Backport bug fix to old release branch, 3) Apply feature commit to different branch, 4) Recover commit from deleted branch. Syntax: 'git cherry-pick commit-hash' applies that commit to current branch. Multiple commits: 'git cherry-pick A^..B' applies range. Conflicts: same as merge - resolve and 'git cherry-pick --continue'. Abort: 'git cherry-pick --abort'. Gotcha: cherry-pick creates NEW commit with different hash - looks duplicate in history. Don't cherry-pick commits that already exist in target branch. When NOT to use: if you need multiple commits, merge is better. Cherry-pick is for selective commit porting. Alternative: 'git cherry-pick -x' adds '(cherry picked from...)' to commit message for tracking. Useful for hotfix workflows where same fix goes to multiple release branches."}]}
{"messages": [{"role": "user", "content": "How does git rebase -i (interactive rebase) work?"}, {"role": "assistant", "content": "Interactive rebase lets you edit commit history: squash, reword, reorder, edit, drop commits. Usage: 'git rebase -i HEAD~5' opens editor with last 5 commits. Commands: pick (keep commit), reword (change message), edit (amend commit), squash (combine with previous, keep both messages), fixup (combine, discard this message), drop (delete commit). Reorder by moving lines. Workflow: 1) List commits in editor, 2) Change 'pick' to action, 3) Save and exit, 4) Git executes actions, 5) Resolve conflicts if any, 'git rebase --continue'. Common uses: clean up messy commit history before PR (squash WIP commits), fix typo in old commit message (reword), combine related commits (fixup), remove accidental commit (drop). Example: 5 commits → squash 4 into 1 clean commit before merging. Danger: rewrites history - only for unpushed commits or force-push to personal branch. NEVER on shared/main branch. Abort: 'git rebase --abort'. Pro tip: 'git commit --fixup=commit-hash' + 'git rebase -i --autosquash' automatically marks fixups."}]}
{"messages": [{"role": "user", "content": "What are git tags and how do I use them?"}, {"role": "assistant", "content": "Git tags are immutable pointers to specific commits, typically for release versions. Two types: 1) Lightweight tag - just pointer: 'git tag v1.0.0', 2) Annotated tag - full object with message, tagger, date: 'git tag -a v1.0.0 -m \"Release 1.0\"'. Annotated preferred for releases. Use cases: mark release versions (v1.2.3), mark important milestones, reference specific commit easily. Commands: 'git tag' lists tags, 'git tag -l \"v1.*\"' filters, 'git show v1.0.0' shows tag details, 'git tag -d v1.0.0' deletes local tag. Push tags: 'git push origin v1.0.0' (specific) or 'git push origin --tags' (all). Delete remote tag: 'git push origin --delete v1.0.0'. Checkout tag: 'git checkout v1.0.0' (detached HEAD state). Semantic versioning: MAJOR.MINOR.PATCH (v2.1.3). Tags vs branches: tags don't move, branches move with commits. Automated: CI/CD can auto-tag on release. GitHub uses tags for Releases page. Tag conventions: v prefix (v1.0.0) or no prefix (1.0.0) - be consistent!"}]}
{"messages": [{"role": "user", "content": "How do I clean up my local Git repository?"}, {"role": "assistant", "content": "Repository cleanup commands: 1) Delete merged branches: 'git branch --merged | grep -v \"\\*\\|main\\|develop\" | xargs git branch -d' removes local branches already merged, 2) Prune remote tracking: 'git fetch --prune' removes remote-tracking branches for deleted remotes, 'git remote prune origin' alternative, 3) Garbage collection: 'git gc' compresses repo, 'git gc --aggressive --prune=now' deep clean (slow), 4) Remove untracked files: 'git clean -fd' (f=files, d=directories), 'git clean -fX' removes only ignored files, 'git clean -n' dry run, 5) Check repo size: 'git count-objects -vH', 6) Find large files: 'git rev-list --objects --all | git cat-file --batch-check=\"%(objectsize) %(rest)\" | sort -nr | head'. For bloated repos: BFG Repo-Cleaner or 'git filter-branch' to remove large files from history (rewrites history!). Regular maintenance: delete old branches, clean untracked files weekly, gc monthly. Workflow: fetch --prune, delete merged branches, clean -fd, gc. Caution: git clean is destructive - always dry run first!"}]}
{"messages": [{"role": "user", "content": "What's the difference between git reset --soft, --mixed, and --hard?"}, {"role": "assistant", "content": "git reset modes control what happens to staging area and working directory: 1) --soft: moves HEAD, keeps staged + working directory. Use: undo commit but keep changes staged for new commit. 'git reset --soft HEAD~1' uncommits but keeps files staged. 2) --mixed (default): moves HEAD, unstages changes, keeps working directory. Use: undo commit and staging, but keep file changes. 'git reset HEAD~1' or 'git reset --mixed HEAD~1' uncommits and unstages. 3) --hard: moves HEAD, clears staging AND working directory. DESTRUCTIVE - loses all changes. Use: abandon all changes, return to clean state. 'git reset --hard HEAD~1' deletes everything. Recovery: --hard changes recoverable via reflog ('git reflog', then 'git reset --hard HEAD@{1}'). Mnemonic: soft = just commit, mixed = commit + stage, hard = commit + stage + files. Common workflow: 'git reset --soft HEAD~3' to combine last 3 commits, then 'git commit' to create one. Never reset --hard without checking reflog safety net exists!"}]}
{"messages": [{"role": "user", "content": "How do I configure Git to ignore files?"}, {"role": "assistant", "content": "Gitignore configuration: 1) Create .gitignore in repo root, 2) Add patterns: exact name (secrets.txt), wildcards (*.log), directories (node_modules/), negation (!keep.log). 3) Commit .gitignore. Patterns: '*.pyc' ignores all pyc files, 'cache/' ignores directory, '/config.local' ignores root file only, '**/temp' ignores temp at any level. Global gitignore: 'git config --global core.excludesfile ~/.gitignore_global' for personal ignores (OS files, editor files). Gitignore already-tracked files: 'git rm --cached file' untracks but keeps file, add to .gitignore, commit. Check what's ignored: 'git check-ignore -v file' shows which rule ignores file. Templates: github.com/github/gitignore has templates for languages/frameworks. Common ignores: node_modules/, .env, *.log, .DS_Store, __pycache__/, dist/. Gotcha: gitignore doesn't affect already-tracked files - must untrack first. .gitignore syntax: comments with #, blank lines ignored. Advanced: .git/info/exclude for local-only ignores (not committed)."}]}
{"messages": [{"role": "user", "content": "What's git bisect and how can it help find bugs?"}, {"role": "assistant", "content": "git bisect uses binary search to find commit that introduced bug. Workflow: 1) 'git bisect start' begins bisect, 2) 'git bisect bad' marks current commit as broken, 3) 'git bisect good <commit>' marks known good commit (e.g., last release tag), 4) Git checks out middle commit, 5) Test if bug exists, mark 'git bisect good' or 'git bisect bad', 6) Repeat until Git identifies exact commit, 7) 'git bisect reset' returns to original state. Example: bug appeared somewhere in last 100 commits - manually checking takes 100 tests, bisect finds it in log2(100) ≈ 7 tests. Automated: 'git bisect run ./test.sh' runs script automatically, script exit 0=good, non-zero=bad. Git bisects until finds breaking commit. Use when: regression with unknown cause, works in old version, broken in new. Output: shows culprit commit and message. Then: 'git show <bad-commit>' to see changes, revert or fix. Bisect saved me hours debugging - highly underutilized feature!"}]}
{"messages": [{"role": "user", "content": "How do I work with Git submodules?"}, {"role": "assistant", "content": "Submodules embed one repo inside another at specific commit. Add: 'git submodule add https://github.com/user/lib.git libs/mylib' creates .gitmodules file, clones repo to libs/mylib. Clone repo with submodules: 'git clone --recurse-submodules <repo>' or after cloning: 'git submodule init && git submodule update'. Update submodule: cd into submodule, pull, commit in parent repo. Update all: 'git submodule update --remote'. Remove: 'git submodule deinit <path> && git rm <path>'. Gotcha: submodules point to specific commit, not branch - must manually update. When to use: shared libraries across projects, large dependencies. When NOT: simple dependencies (use package managers), frequently changing code (use monorepo). Alternatives: git subtree (merges repo into subdirectory), package managers (npm, pip). Submodules complex - many teams avoid. If using: document clearly, automate updates, use --recurse-submodules flag. Common pain: forgetting to push submodule changes before parent, others can't clone. Trend: moving away from submodules to monorepos or package managers."}]}
{"messages": [{"role": "user", "content": "What are Git hooks and how can I use them?"}, {"role": "assistant", "content": "Git hooks are scripts that run automatically on git events. Location: .git/hooks/ (samples included). Client-side hooks: pre-commit (before commit, lint/test), prepare-commit-msg (edit default message), commit-msg (validate message format), post-commit (notifications), pre-push (run tests before push). Server-side: pre-receive, post-receive, update. Setup: create executable script in .git/hooks/, remove .sample extension. Example pre-commit: '#!/bin/bash\\nnpm test\\nif [ $? -ne 0 ]; then\\n  echo \"Tests failed\"\\n  exit 1\\nfi'. Exit non-zero to abort git operation. Share hooks: can't commit .git/hooks (local only), workaround: keep scripts in repo (e.g., scripts/hooks/), symlink to .git/hooks/, or use tools like husky (npm), pre-commit framework (Python). Use cases: enforce code style (eslint/black), run tests, prevent force push to main, validate commit messages, update ticket status. Bypass: 'git commit --no-verify' skips hooks (use sparingly!). Hooks make quality checks automatic - essential for team consistency!"}]}
{"messages": [{"role": "user", "content": "How do I use git blame effectively?"}, {"role": "assistant", "content": "git blame shows who last modified each line and when. Basic: 'git blame file.txt' shows commit hash, author, date per line. Better: 'git blame -L 10,20 file.txt' blames specific line range. Ignore whitespace: 'git blame -w file.txt'. See commit message: 'git blame file.txt | head -1 | cut -d' ' -f1 | xargs git show'. Follow renames: 'git blame -C file.txt' tracks code moved between files. GUI: IDEs have blame integration (VS Code: GitLens, IntelliJ: Annotate). Use cases: 1) Find who wrote code to ask questions, 2) Understand why change was made (see commit message), 3) Track when bug introduced, 4) Code archaeology. Don't use for: blaming people! Purpose is understanding, not accusation. Pro tips: 'git blame --since=\"3 months ago\"' ignores old changes, 'git log -p -S\"function_name\"' finds when function added. Alternative: 'git log -p file.txt' shows full file history. Blame is educational - shows evolution of code, reveals architectural decisions. Combine with commit messages to understand intent."}]}
{"messages": [{"role": "user", "content": "What's the difference between fork and clone?"}, {"role": "assistant", "content": "Fork: creates your own copy of repo on GitHub/GitLab server, independent repo under your account, used for contributing to others' projects. Clone: downloads repo to local machine, creates local copy, used for your own work or contribution setup. Workflow: 1) Fork on GitHub (click Fork button), 2) Clone your fork: 'git clone https://github.com/YOU/repo.git', 3) Add upstream: 'git remote add upstream https://github.com/ORIGINAL/repo.git', 4) Work on feature, 5) Push to your fork, 6) Open PR from your fork to original. Fork vs clone: fork = server copy, clone = local copy. You can clone without forking (for your own repos), must fork to contribute to others' repos (no push access). Keeping fork updated: 'git fetch upstream && git merge upstream/main'. Alternative workflow: clone original directly, create branch, push to your fork (if added as remote). Forks useful for: open source contribution, experimenting without affecting original, creating derivative project. Some orgs: internal forks for team isolation."}]}
{"messages": [{"role": "user", "content": "How do I sign commits with GPG?"}, {"role": "assistant", "content": "GPG signing proves commits authenticity. Setup: 1) Generate key: 'gpg --full-generate-key' (RSA 4096), 2) List keys: 'gpg --list-secret-keys --keyid-format=long', note key ID, 3) Configure Git: 'git config --global user.signingkey KEY_ID', 4) Enable signing: 'git config --global commit.gpgsign true', 5) Export public key: 'gpg --armor --export KEY_ID', 6) Add to GitHub (Settings → SSH and GPG keys). Sign commit: 'git commit -S -m \"Message\"' (automatic if gpgsign=true). Verify: 'git log --show-signature', GitHub shows \"Verified\" badge. Sign tags: 'git tag -s v1.0 -m \"Message\"'. Troubleshooting: 'gpg: signing failed: Inappropriate ioctl for device' → 'export GPG_TTY=$(tty)' in .bashrc. Why sign: proves you made commit (not spoofed), important for maintainers, security-critical projects. Required by: some orgs, Linux kernel, security tools. Downside: extra setup, key management. Alternative: SSH signing (newer, simpler): 'git config gpg.format ssh'. Signed commits = chain of trust!"}]}
{"messages": [{"role": "user", "content": "What are the best practices for branch naming?"}, {"role": "assistant", "content": "Branch naming conventions improve clarity and automation. Patterns: 1) Type-based: 'feature/user-login', 'bugfix/payment-error', 'hotfix/security-patch', 'release/v1.2.0', 2) Ticket-based: 'feature/JIRA-123-add-api', 'fix/GH-456-crash-on-ios', 3) User-based: 'john/experiment-new-ui'. Rules: lowercase, hyphens not underscores, no spaces, descriptive, short (<40 chars). Prefixes: feature/ (new functionality), bugfix/ (fix bugs), hotfix/ (urgent production fix), release/ (release preparation), chore/ (maintenance), docs/ (documentation). Team agreement: document conventions in CONTRIBUTING.md. Tools enforce: git hooks can validate names, CI can require pattern. GitHub/GitLab: branch protection by pattern (protect 'main', 'release/*'). Bad names: 'test', 'tmp', 'asdf', 'john-branch-2'. Good: 'feature/oauth-integration', 'bugfix/login-timeout-issue'. Delete after merge: 'git branch -d feature-name' keeps repo clean. Some teams: add username prefix for clarity in large teams. Automation: scripts can extract ticket numbers from branch names for automated linking."}]}
{"messages": [{"role": "user", "content": "How do I recover a deleted branch?"}, {"role": "assistant", "content": "Branch recovery using reflog: 1) 'git reflog' shows all HEAD movements, find entry before deletion, 2) Look for 'checkout: moving from deleted-branch to main', note commit hash, 3) 'git branch recovered-branch <commit-hash>' recreates branch, 4) 'git checkout recovered-branch' to verify. Or: 'git reflog show deleted-branch' if you remember name. If merged before deletion: branch tip is in main history, 'git log --all' find commit, recreate. If pushed: fetch from remote, 'git checkout -b recovered origin/deleted-branch'. Prevention: branches pushed to remote are safe, GitHub/GitLab have 'recently deleted' UI. Timeframe: reflog keeps entries 90 days by default. Can't recover if: 1) Never committed to branch, 2) Did 'git gc' with prune, 3) Past reflog expiration. Pro tip: create tag before risky operations: 'git tag backup-branch-name'. Command to prevent accidents: alias git branch delete to prompt confirmation. Deleted != lost in Git - almost everything recoverable within 90 days!"}]}
{"messages": [{"role": "user", "content": "What's git worktree and when should I use it?"}, {"role": "assistant", "content": "git worktree allows multiple working directories from same repo. Instead of stashing/switching branches, work on multiple branches simultaneously. Usage: 'git worktree add ../project-feature feature-branch' creates separate directory with feature-branch checked out. List: 'git worktree list', remove: 'git worktree remove ../project-feature'. Use cases: 1) Review PR while working on feature (checkout PR in separate worktree), 2) Run long tests on one branch while developing on another, 3) Compare implementations side-by-side, 4) Hotfix on main while working on feature (no stashing). Benefits: no context switching, no stash juggling, parallel work, separate build artifacts. Structure: single .git in main worktree, others reference it. Commits in any worktree affect same repository. Gotcha: can't checkout same branch in multiple worktrees. Limits: same branch restrictions apply. When NOT: simple branch switching (checkout faster), disk space limited (each worktree duplicates files). Modern feature, underutilized! Replaces making multiple clones of same repo. Great for complex workflows!"}]}
{"messages": [{"role": "user", "content": "How do I handle large files in Git (Git LFS)?"}, {"role": "assistant", "content": "Git LFS (Large File Storage) handles large files efficiently. Regular Git stores full copies, bloats repo. LFS stores pointers in Git, actual files on LFS server. Setup: 1) Install: 'git lfs install', 2) Track file types: 'git lfs track \"*.psd\"', creates .gitattributes, 3) Commit .gitattributes, 4) Add/commit large files normally, 5) Push: 'git lfs push origin main' or just 'git push'. Clone LFS repo: 'git lfs clone <url>' or 'git clone <url> && git lfs pull'. Commands: 'git lfs ls-files' shows tracked files, 'git lfs status' shows LFS state. Untrack: edit .gitattributes. Hosting: GitHub (1GB free), GitLab, Bitbucket support LFS. When to use: binary files (images, videos, models), files >100MB, frequently changing binaries. When NOT: text files (Git handles well), rarely changing files, vendor dependencies (use package manager). Alternatives: Git Annex (more features, complex), DVC (data versioning), BFG Repo-Cleaner (remove historical large files). LFS costs: storage + bandwidth, check host limits. Tip: .gitattributes must be committed first!"}]}
{"messages": [{"role": "user", "content": "What are some advanced git log tricks?"}, {"role": "assistant", "content": "Powerful git log options: 1) Graph with colors: 'git log --graph --oneline --decorate --all --color', 2) Custom format: 'git log --pretty=format:\"%h - %an, %ar : %s\"' (hash, author, relative date, subject), 3) Since/until: 'git log --since=\"2 weeks ago\" --until=\"yesterday\"', 4) Author filter: 'git log --author=\"John\"', 5) Grep commit messages: 'git log --grep=\"bug fix\"', 6) File history: 'git log -p filename', shows patches, 7) Search code: 'git log -S\"function_name\"' finds commits adding/removing that string, 8) Stat summary: 'git log --stat', 9) Short stat: 'git log --shortstat --oneline', 10) First parent: 'git log --first-parent' (ignore merge commit details). Combinations: 'git log --oneline --graph --all --author=\"Jane\" --since=\"1 month ago\"'. Aliases: 'git config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"'. Then: 'git lg'. Output to file: 'git log > history.txt'. These make Git log incredibly powerful for code archaeology!"}]}
{"messages": [{"role": "user", "content": "How do I split a commit into multiple commits?"}, {"role": "assistant", "content": "Split commit using interactive rebase: 1) 'git rebase -i HEAD~3' (if commit is in last 3), 2) Change 'pick' to 'edit' for commit to split, 3) Save and exit, 4) 'git reset HEAD^' uncommits but keeps changes in working directory, 5) 'git add -p' for interactive staging (choose hunks), 6) 'git commit -m \"First part\"', 7) Repeat add/commit for other parts, 8) 'git rebase --continue' to finish. Alternative: 'git reset --soft HEAD^' keeps changes staged, then unstage parts and commit separately. Why split: commit does too much, violates single responsibility, hard to revert one piece. Example: commit changed formatting + added feature → split into 'Reformat code' and 'Add feature' commits. Interactive add: 'git add -p' shows each hunk, 'y' stage, 'n' skip, 's' split smaller, 'e' edit manually. Result: one commit becomes multiple atomic commits. Only for unpushed commits! If pushed: need force push or make new commits. Clean history improves code review and git blame clarity."}]}
{"messages": [{"role": "user", "content": "What's the difference between git fetch origin and git pull origin?"}, {"role": "assistant", "content": "Both sync with remote but differently: 'git fetch origin' downloads commits/refs from origin, updates remote-tracking branches (origin/main), doesn't change your local branches, safe - can review before integrating. 'git pull origin' = fetch + merge - downloads AND merges into current branch, can create merge commit or cause conflicts, less safe. Detailed: fetch updates .git/refs/remotes/origin/*, pull updates current branch. After fetch: 'git log origin/main' review changes, 'git diff main origin/main' see differences, decide to merge/rebase. After pull: already merged, may have conflicts to resolve. Best practice: use fetch for careful workflow, especially on shared branches. Pull for quick updates on personal branches. Configure pull behavior: 'git config pull.rebase true' makes pull use rebase instead of merge (cleaner history). Command variants: 'git fetch' (all remotes), 'git fetch origin main' (specific branch), 'git pull' (current branch's upstream). My workflow: always fetch first, review, then explicit merge/rebase. Prevents surprises, better control. Pull is convenient but hides what's happening."}]}
{"messages": [{"role": "user", "content": "How can I find which commit introduced a bug?"}, {"role": "assistant", "content": "Methods to find bug introduction: 1) git bisect - binary search (explained separately), fastest for large history, 2) git blame - find who changed line: 'git blame -L10,15 file.py', see commit, 'git show <commit>' to review, 3) git log with search - 'git log -S\"buggy_function\" -p' shows commits that added/removed that code, 4) git log file - 'git log -p -- file.py' shows all changes to file, manually review. Strategies: start with when bug was first noticed, check if exists in last release tag, bisect between tag and current. Reproduction: write test that fails on bug, automate bisect: 'git bisect run ./test_for_bug.sh'. Blame limitations: shows last change, not introduction - use 'git log -p -M' to track through renames. Time-based: 'git log --since=\"2024-01-01\" --until=\"2024-01-15\"' narrows to deployment window. Combination: bisect to find commit, blame to find line, log to understand context. Document: when found, add comment or test explaining issue. Prevention: small commits make bisect more precise, good commit messages help identify culprit quickly!"}]}
