{"messages": [{"role": "user", "content": "What's the difference between find_element and find_elements in Selenium?"}, {"role": "assistant", "content": "find_element() returns a single WebElement (the first match) and raises NoSuchElementException if not found. find_elements() returns a list of WebElements (all matches) and returns an empty list [] if nothing found - never raises exception. Use find_element when you expect exactly one match, find_elements when you need to iterate multiple elements or check if element exists without exception."}]}
{"messages": [{"role": "user", "content": "When should I use implicit vs explicit waits in Selenium?"}, {"role": "assistant", "content": "Implicit waits (driver.implicitly_wait(10)) apply globally to all find_element calls - driver polls DOM for specified seconds. Simple but inflexible. Explicit waits (WebDriverWait) are targeted - wait for specific conditions on specific elements (visibility, clickability, text present). More powerful and recommended. NEVER mix both - causes unpredictable wait times. Best practice: use explicit waits with Expected Conditions for dynamic content, avoid implicit waits in modern Selenium."}]}
{"messages": [{"role": "user", "content": "How do I handle StaleElementReferenceException in Selenium?"}, {"role": "assistant", "content": "StaleElementReferenceException occurs when an element reference becomes invalid after DOM update (AJAX reload, navigation). Solutions: 1) Re-find the element after DOM change instead of reusing old reference, 2) Use explicit wait for element to be present again, 3) Wrap in try/except and retry finding element. Example: instead of storing element = driver.find_element(...) and reusing, call find_element fresh each time after page changes. Wait for staleness: wait.until(EC.staleness_of(element))."}]}
{"messages": [{"role": "user", "content": "What's the best way to select elements in Selenium - ID, CSS, or XPath?"}, {"role": "assistant", "content": "Priority order: 1) ID - fastest and most reliable if available (By.ID, 'unique-id'), 2) CSS selectors - fast, readable, good for classes/attributes (By.CSS_SELECTOR, '.class-name'), 3) XPath - powerful but slower, use when CSS can't handle it (By.XPATH, '//div[@data-test=\"value\"]'). Avoid: tag names alone (too generic), link text (fragile to changes). Modern practice: use data-testid attributes for test automation: [data-testid=\"login-button\"]."}]}
{"messages": [{"role": "user", "content": "How can I run Selenium in headless mode?"}, {"role": "assistant", "content": "Use ChromeOptions to enable headless mode: 'options = Options(); options.add_argument('--headless'); driver = webdriver.Chrome(options=options)'. Headless runs browser without GUI - faster, works on servers without display. Also add '--disable-gpu' and '--window-size=1920,1080' for stability. For Firefox: options.headless = True. Useful for CI/CD, scraping, background automation. Note: some websites detect headless mode, may need additional stealth options."}]}
{"messages": [{"role": "user", "content": "How do I handle multiple browser windows or tabs in Selenium?"}, {"role": "assistant", "content": "Use window handles: 'driver.window_handles' returns list of all window IDs. Switch with 'driver.switch_to.window(handle)'. Common pattern: 1) Store original: original = driver.current_window_handle, 2) Open new tab via JavaScript or link click, 3) Switch: driver.switch_to.window(driver.window_handles[-1]), 4) Do work in new window, 5) Close: driver.close(), 6) Switch back: driver.switch_to.window(original). Use driver.quit() to close all windows, driver.close() for current only."}]}
{"messages": [{"role": "user", "content": "What's the correct way to wait for an element to be clickable?"}, {"role": "assistant", "content": "Use explicit wait with element_to_be_clickable condition: 'from selenium.webdriver.support.ui import WebDriverWait; from selenium.webdriver.support import expected_conditions as EC; wait = WebDriverWait(driver, 10); element = wait.until(EC.element_to_be_clickable((By.ID, 'submit-btn')))'. This waits for element to be both visible AND enabled. Then safely call element.click(). Prevents ElementNotInteractableException and ElementClickInterceptedException. Timeout after 10 seconds raises TimeoutException if element never becomes clickable."}]}
{"messages": [{"role": "user", "content": "How can I interact with dropdown menus in Selenium?"}, {"role": "assistant", "content": "For standard <select> dropdowns, use Select class: 'from selenium.webdriver.support.ui import Select; dropdown = Select(driver.find_element(By.ID, 'dropdown-id'))'. Then: select_by_visible_text('Option Text'), select_by_value('value_attribute'), or select_by_index(2). For custom dropdowns (div-based), treat as regular elements: click to open, find option element, click it. Check selected: dropdown.first_selected_option.text. Get all options: dropdown.options."}]}
{"messages": [{"role": "user", "content": "What's the best way to handle dynamic content that loads with AJAX?"}, {"role": "assistant", "content": "Use explicit waits with appropriate conditions: 1) Wait for element visibility: EC.visibility_of_element_located(), 2) Wait for text to appear: EC.text_to_be_present_in_element(), 3) Wait for element count: EC.presence_of_all_elements_located(). Example: WebDriverWait(driver, 10).until(EC.visibility_of_element_located((By.ID, 'ajax-content'))). For AJAX that removes elements, use: EC.invisibility_of_element(). Can also wait for JavaScript: driver.execute_script('return jQuery.active == 0') for jQuery AJAX. Never use time.sleep() - unreliable and slow."}]}
{"messages": [{"role": "user", "content": "How do I execute JavaScript code in the browser with Selenium?"}, {"role": "assistant", "content": "Use execute_script(): 'driver.execute_script('return document.title;')' returns value. Pass arguments: driver.execute_script('arguments[0].click();', element) where element is WebElement. Common uses: 1) Scroll: execute_script('window.scrollTo(0, 500)'), 2) Click hidden elements: execute_script('arguments[0].click()', element), 3) Modify DOM: execute_script('arguments[0].style.border=\"3px solid red\"', element), 4) Access storage: execute_script('return localStorage.getItem(\"key\")'). Use for actions Selenium can't do natively."}]}
{"messages": [{"role": "user", "content": "How can I take screenshots in Selenium for debugging?"}, {"role": "assistant", "content": "Full page screenshot: driver.save_screenshot('/path/screenshot.png'). Element screenshot: element.screenshot('/path/element.png'). For debugging, take screenshots in exception handlers: 'try: ... except Exception as e: driver.save_screenshot(f'error_{timestamp}.png'); raise'. Get as base64 for embedding: driver.get_screenshot_as_base64(). For PNG bytes: driver.get_screenshot_as_png(). Screenshots useful for CI/CD test failures, visual regression testing, or debugging dynamic content issues. File saved with .png extension."}]}
{"messages": [{"role": "user", "content": "How do I handle JavaScript alerts, confirms, and prompts?"}, {"role": "assistant", "content": "Switch to alert: 'alert = driver.switch_to.alert'. Then: alert.accept() to click OK, alert.dismiss() to click Cancel, alert.text to read message, alert.send_keys('text') for prompts. Always handle alerts immediately - other actions blocked. Use explicit wait for alert: WebDriverWait(driver, 5).until(EC.alert_is_present()). Example for prompt: driver.switch_to.alert.send_keys('input'); driver.switch_to.alert.accept(). Alerts are modal - must interact before continuing automation. No alert present raises NoAlertPresentException."}]}
{"messages": [{"role": "user", "content": "What's the proper way to work with iframes in Selenium?"}, {"role": "assistant", "content": "Switch into iframe: 'driver.switch_to.frame(element)' where element is iframe WebElement, or use name/id: driver.switch_to.frame('iframe-name'). Do work inside iframe context. Switch back to main page: driver.switch_to.default_content(). For nested iframes, switch multiple times. Common mistake: trying to interact with iframe content without switching - raises NoSuchElementException. To find iframe: driver.find_element(By.TAG_NAME, 'iframe') or By.ID. Always switch back when done or subsequent find_element will search inside iframe only."}]}
{"messages": [{"role": "user", "content": "How can I handle file uploads in Selenium?"}, {"role": "assistant", "content": "For <input type=\"file\"> elements: find input element and use send_keys with absolute file path: 'file_input = driver.find_element(By.CSS_SELECTOR, 'input[type=\"file\"]'); file_input.send_keys('/absolute/path/to/file.pdf')'. No need to click - send_keys handles it. For hidden inputs, may need JavaScript: driver.execute_script('arguments[0].style.display = \"block\";', file_input). For drag-drop upload widgets, may need to unhide input or use pyautogui. Path must be absolute - relative paths unreliable. Multiple files: send_keys('/path1\\n/path2')."}]}
{"messages": [{"role": "user", "content": "How do I manage cookies in Selenium?"}, {"role": "assistant", "content": "Get all cookies: driver.get_cookies() returns list of dicts. Add cookie: driver.add_cookie({'name': 'session', 'value': 'abc123', 'domain': '.example.com'}). Delete cookie: driver.delete_cookie('cookie_name'). Delete all: driver.delete_all_cookies(). Get specific cookie: driver.get_cookie('name'). Must navigate to domain before adding cookies. Useful for: session hijacking, bypassing login, testing with different sessions. Cookie dict has: name, value, domain, path, secure, httpOnly, expiry. For session persistence, save cookies with pickle, restore later."}]}
{"messages": [{"role": "user", "content": "What are the common exceptions in Selenium and how to handle them?"}, {"role": "assistant", "content": "Common exceptions: 1) NoSuchElementException - element not found, use explicit wait or check if exists, 2) TimeoutException - wait exceeded, increase timeout or verify condition, 3) StaleElementReferenceException - element changed, re-find element, 4) ElementNotInteractableException - element not visible/enabled, wait for visibility, 5) ElementClickInterceptedException - element blocked by overlay, scroll into view or wait, 6) NoAlertPresentException - no alert when switching. Handle with try/except, add waits, or use EC.presence_of_element_located to avoid exceptions. Selenium exceptions in selenium.common.exceptions module."}]}
{"messages": [{"role": "user", "content": "How can I make Selenium undetectable to avoid bot detection?"}, {"role": "assistant", "content": "Stealth techniques: 1) Remove automation flags: options.add_experimental_option('excludeSwitches', ['enable-automation']); options.add_experimental_option('useAutomationExtension', False), 2) Spoof navigator: options.add_argument('--disable-blink-features=AutomationControlled'), 3) Change user agent: options.add_argument('user-agent=Mozilla/5.0...'), 4) Use undetected-chromedriver package (drop-in replacement), 5) Randomize timing with random delays, 6) Use residential proxies, 7) Rotate user agents. Detection methods: navigator.webdriver property, Chrome DevTools protocol, timing patterns. undetected-chromedriver patches most detection vectors automatically."}]}
{"messages": [{"role": "user", "content": "How do I hover over elements in Selenium?"}, {"role": "assistant", "content": "Use ActionChains: 'from selenium.webdriver.common.action_chains import ActionChains; actions = ActionChains(driver); actions.move_to_element(element).perform()'. For hover then click: actions.move_to_element(menu).click(submenu).perform(). Chain multiple actions: actions.move_to_element(el1).pause(1).move_to_element(el2).click().perform(). Useful for dropdown menus, tooltips, hidden elements. Alternative: JavaScript: driver.execute_script('arguments[0].dispatchEvent(new MouseEvent(\"mouseover\"));', element). Must call .perform() to execute action chain. For hover delay, use actions.pause(seconds)."}]}
{"messages": [{"role": "user", "content": "What's the difference between driver.quit() and driver.close()?"}, {"role": "assistant", "content": "driver.close() closes the current browser window/tab only. If multiple tabs open, closes active one, driver still usable for other tabs. driver.quit() closes ALL browser windows/tabs AND ends WebDriver session - driver object unusable after. Best practice: always use quit() in finally block or context manager to ensure cleanup. Example: try: driver.get(...) finally: driver.quit(). Using close() without quit() leaves WebDriver process running (memory leak). quit() also terminates ChromeDriver/geckodriver process. For multi-window scenarios, close() each extra window, then quit() at end."}]}
{"messages": [{"role": "user", "content": "How can I wait for a page to fully load in Selenium?"}, {"role": "assistant", "content": "Selenium waits for document.readyState == 'complete' by default after driver.get(). For AJAX/SPAs, use additional waits: 1) Wait for specific element: WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, 'content'))), 2) Wait for JavaScript: driver.execute_script('return document.readyState') == 'complete', 3) Wait for jQuery: driver.execute_script('return jQuery.active == 0'), 4) Wait for Angular: driver.execute_script('return window.getAllAngularTestabilities().findIndex(x => !x.isStable()) === -1'). No single 'page loaded' condition - depends on app framework. Best: wait for specific element indicating content ready."}]}
{"messages": [{"role": "user", "content": "How do I handle keyboard actions in Selenium?"}, {"role": "assistant", "content": "Use send_keys() for typing: element.send_keys('text'). For special keys, import Keys: 'from selenium.webdriver.common.keys import Keys; element.send_keys(Keys.ENTER)'. Common keys: Keys.RETURN, Keys.TAB, Keys.ESCAPE, Keys.BACKSPACE, Keys.DELETE, Keys.ARROW_DOWN. Modifiers: Keys.CONTROL + 'a' for Ctrl+A. With ActionChains for complex sequences: actions.key_down(Keys.SHIFT).send_keys('abc').key_up(Keys.SHIFT).perform(). To press key without element: actions.send_keys(Keys.ESCAPE).perform(). Keys.chord() for simultaneous: element.send_keys(Keys.chord(Keys.CONTROL, 'a'))."}]}
{"messages": [{"role": "user", "content": "How can I scroll to an element in Selenium?"}, {"role": "assistant", "content": "JavaScript scroll into view: 'driver.execute_script('arguments[0].scrollIntoView();', element)' or with options: execute_script('arguments[0].scrollIntoView({behavior: \"smooth\", block: \"center\"});', element). Alternative with ActionChains: actions.move_to_element(element).perform() scrolls automatically. Scroll by pixels: driver.execute_script('window.scrollBy(0, 500);'). Scroll to bottom: execute_script('window.scrollTo(0, document.body.scrollHeight);'). For infinite scroll: repeatedly scroll down in loop. scrollIntoView() most reliable for ensuring element visible before interaction."}]}
{"messages": [{"role": "user", "content": "What's the best way to debug Selenium tests?"}, {"role": "assistant", "content": "Debugging techniques: 1) Screenshots on failure: driver.save_screenshot('error.png'), 2) Print page source: print(driver.page_source), 3) Console logs: driver.get_log('browser') for JS errors, 4) Add time.sleep() to pause and observe, 5) Run non-headless to watch, 6) Use breakpoints with pdb/debugger, 7) Verbose logging: enable Selenium wire logs, 8) Check element state: print(element.is_displayed(), element.is_enabled()), 9) Try in browser DevTools first, 10) Explicit waits with try/except to catch timing issues. Most issues: timing (use waits), wrong selectors (test in DevTools), or iframe context (check switching)."}]}
{"messages": [{"role": "user", "content": "How do I handle HTTP authentication popups in Selenium?"}, {"role": "assistant", "content": "Pass credentials in URL: 'driver.get('https://username:password@example.com')'. This handles HTTP Basic Auth popup directly. Alternative: use Chrome DevTools Protocol (CDP): driver.execute_cdp_cmd('Network.enable', {}); driver.execute_cdp_cmd('Network.setExtraHTTPHeaders', {'headers': {'Authorization': 'Basic <base64>'})}. For Windows NTLM auth, need different approach (AutoIt, Robot Framework). URL method easiest but exposes credentials. For security, use environment variables: driver.get(f'https://{os.getenv(\"USER\")}:{os.getenv(\"PASS\")}@example.com'). Note: only works for HTTP auth, not JavaScript modal dialogs."}]}
{"messages": [{"role": "user", "content": "How can I change the download directory in Selenium Chrome?"}, {"role": "assistant", "content": "Set Chrome preferences: 'options = Options(); prefs = {\"download.default_directory\": \"/path/to/downloads\", \"download.prompt_for_download\": False, \"download.directory_upgrade\": True, \"safebrowsing.enabled\": True}; options.add_experimental_option(\"prefs\", prefs); driver = webdriver.Chrome(options=options)'. Path must be absolute. For headless, also add: options.add_argument('--disable-gpu'); options.add_argument('--disable-software-rasterizer'). To wait for download completion, poll directory for file existence. Chrome doesn't provide download complete event - need to check file size stabilizes or use selenium-wire for network monitoring."}]}
{"messages": [{"role": "user", "content": "How do I run Selenium tests in parallel?"}, {"role": "assistant", "content": "Use pytest-xdist or unittest parallel runners. Each test needs separate WebDriver instance: use fixtures/setUp. Example with pytest: 'pytest -n 4 tests/' runs 4 parallel processes. Use ThreadPoolExecutor for thread-based: multiple drivers in threads. For distributed: Selenium Grid - run tests on multiple machines/browsers. Key: each thread/process has own driver instance, no sharing. In CI/CD: parallel jobs in GitHub Actions/Jenkins. Caution: parallel increases resource usage (CPU/memory), may need headless mode. Grid setup: hub + nodes, tests connect to hub which distributes to nodes."}]}
{"messages": [{"role": "user", "content": "What are Page Object Model (POM) best practices in Selenium?"}, {"role": "assistant", "content": "POM pattern: separate page structure from test logic. Create class per page: 'class LoginPage: def __init__(self, driver): self.driver = driver; self.username = (By.ID, 'user'); self.password = (By.ID, 'pass'); def login(self, user, pwd): self.driver.find_element(*self.username).send_keys(user); ...'. Benefits: reusable, maintainable, readable tests. Best practices: 1) One class per page, 2) Locators as class attributes, 3) Methods for user actions (not raw clicks), 4) Return page objects for navigation, 5) Use @property for element getters. Tests become: page = LoginPage(driver); page.login('user', 'pass'). Separate locators, actions, and assertions."}]}
{"messages": [{"role": "user", "content": "How can I integrate Selenium with pytest?"}, {"role": "assistant", "content": "Use pytest fixtures for driver setup: '@pytest.fixture; def driver(): driver = webdriver.Chrome(); yield driver; driver.quit()'. Then: 'def test_login(driver): driver.get(\"url\"); assert ...'. For parametrization: @pytest.mark.parametrize('browser', ['chrome', 'firefox']). Pytest plugins: pytest-selenium (auto fixtures), pytest-html (reports), pytest-xdist (parallel). Fixture scopes: function (default, new driver per test), class, module, session (share driver). Use autouse for automatic setup. Markers for browser-specific tests: @pytest.mark.chrome. Pytest advantages: fixtures, parametrization, markers, better reporting than unittest."}]}
{"messages": [{"role": "user", "content": "How do I handle CAPTCHA in Selenium automation?"}, {"role": "assistant", "content": "CAPTCHA designed to block automation - no legitimate way to solve programmatically. Options: 1) Test environment: disable CAPTCHA or use test key, 2) Session reuse: login manually, export cookies, load in automation, 3) CAPTCHA solving services (2captcha, Anti-Captcha) - send image, get solution via API (against ToS), 4) ML models (unreliable, complex), 5) Skip tests requiring CAPTCHA, test other flows. Best practice: work with developers to add automation-friendly auth for testing (API keys, test accounts without CAPTCHA). Don't try to break CAPTCHA in production - violates terms of service. For testing, request CAPTCHA bypass mechanism."}]}
