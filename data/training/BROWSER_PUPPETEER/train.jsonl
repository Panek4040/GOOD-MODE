{"messages": [{"role": "user", "content": "What's the difference between Puppeteer and Selenium?"}, {"role": "assistant", "content": "Puppeteer is Node.js-only, controls Chrome/Chromium via DevTools Protocol - faster, more reliable. Selenium supports multiple browsers (Chrome, Firefox, Safari, Edge) and languages (Python, Java, JavaScript, C#) via WebDriver protocol. Puppeteer advantages: better for Chrome automation, built-in features (PDF generation, request interception), faster, official Google tool. Selenium advantages: multi-browser support, language flexibility, larger ecosystem. Use Puppeteer for Chrome-specific tasks, Selenium for cross-browser testing."}]}
{"messages": [{"role": "user", "content": "How do I wait for dynamic content to load in Puppeteer?"}, {"role": "assistant", "content": "Use waitForSelector(): 'await page.waitForSelector('div.content')' waits for element to appear in DOM. Options: waitForNavigation() for page loads, waitForFunction() for custom conditions: 'await page.waitForFunction(() => document.querySelectorAll('.item').length > 10)'. Best: combine with networkidle0 or networkidle2 in goto(): 'await page.goto(url, {waitUntil: 'networkidle2'})' waits until no more than 2 network connections for 500ms. For AJAX, waitForResponse(): 'await page.waitForResponse(response => response.url().includes('/api/data'))'. Avoid waitForTimeout() - unreliable."}]}
{"messages": [{"role": "user", "content": "How can I make Puppeteer undetectable?"}, {"role": "assistant", "content": "Use puppeteer-extra with stealth plugin: 'const puppeteer = require('puppeteer-extra'); const StealthPlugin = require('puppeteer-extra-plugin-stealth'); puppeteer.use(StealthPlugin()); const browser = await puppeteer.launch();'. This patches: navigator.webdriver property, Chrome runtime detection, permissions API, plugins array, WebGL vendor, and more. Additional: run non-headless (headless has tells), randomize viewport sizes, use residential proxies, add human-like delays, rotate user agents. Most advanced detection uses behavioral analysis - timing patterns, mouse movements. For heavy bot detection, may need 2captcha or similar."}]}
{"messages": [{"role": "user", "content": "How do I intercept and modify network requests in Puppeteer?"}, {"role": "assistant", "content": "Enable interception: 'await page.setRequestInterception(true)'. Then use page.on('request') to intercept: Block resources: 'page.on('request', req => req.resourceType() === 'image' ? req.abort() : req.continue())'. Modify requests: 'page.on('request', req => { req.continue({headers: {...req.headers(), 'Authorization': 'Bearer token'}, method: 'POST', postData: 'data=value'}); })'. Mock responses: 'page.on('request', req => { if (req.url().includes('/api/')) req.respond({status: 200, body: JSON.stringify({mock: 'data'})}); else req.continue(); })'. Useful for testing, blocking ads, injecting headers, API mocking."}]}
{"messages": [{"role": "user", "content": "What's the best way to handle authentication in Puppeteer?"}, {"role": "assistant", "content": "Multiple approaches: 1) HTTP Basic Auth: 'await page.authenticate({username: 'user', password: 'pass'})' before goto(), 2) Cookie-based: save cookies after login 'const cookies = await page.cookies(); fs.writeFileSync('cookies.json', JSON.stringify(cookies))', then restore: 'await page.setCookie(...cookies)', 3) Form login: automate filling username/password fields, 4) Session storage: 'await page.evaluate(() => localStorage.setItem('token', 'abc123'))'. For production, use cookie persistence - much faster than logging in each time. Store cookies securely, refresh when expired. For testing multiple accounts, use separate browser contexts."}]}
{"messages": [{"role": "user", "content": "How can I scrape data from infinite scroll pages?"}, {"role": "assistant", "content": "Scroll and wait pattern: 'let previousHeight; while (true) { previousHeight = await page.evaluate('document.body.scrollHeight'); await page.evaluate('window.scrollTo(0, document.body.scrollHeight)'); await page.waitForTimeout(2000); let newHeight = await page.evaluate('document.body.scrollHeight'); if (newHeight === previousHeight) break; }'. Alternative: scroll incrementally and wait for new elements: 'for (let i = 0; i < 10; i++) { await page.evaluate(() => window.scrollBy(0, window.innerHeight)); await page.waitForFunction(`document.querySelectorAll('.item').length > ${(i+1)*10}`); }'. Extract data after each scroll or at end. Set max iterations to prevent infinite loops."}]}
{"messages": [{"role": "user", "content": "How do I handle multiple browser tabs in Puppeteer?"}, {"role": "assistant", "content": "Get all pages: 'const pages = await browser.pages()'. Open new tab: 'const newPage = await browser.newPage()'. Switch contexts - no explicit switch needed, just use page reference. Example: 'const page1 = await browser.newPage(); const page2 = await browser.newPage(); await page1.goto('url1'); await page2.goto('url2');'. For popup windows, listen for target: 'browser.on('targetcreated', async target => { if (target.type() === 'page') { const popup = await target.page(); } })'. Close tab: 'await page.close()'. Puppeteer handles multiple pages better than Selenium - each page is independent object."}]}
{"messages": [{"role": "user", "content": "What's the difference between page.evaluate() and page.$$eval()?"}, {"role": "assistant", "content": "page.evaluate() runs arbitrary JavaScript in page context: 'await page.evaluate(() => document.title)'. Can't access Node.js scope - runs in browser. page.$$eval() is shorthand for selecting elements then evaluating: 'await page.$$eval('a', links => links.map(l => l.href))' equivalent to 'await page.evaluate(() => Array.from(document.querySelectorAll('a')).map(l => l.href))'. Also page.$eval() for single element. Use $$eval for common pattern of selecting + extracting data. Note: can't pass complex objects from Node to evaluate - only JSON-serializable values. For element handles: use page.$() then evaluate on handle."}]}
{"messages": [{"role": "user", "content": "How can I generate PDFs with Puppeteer?"}, {"role": "assistant", "content": "Use page.pdf(): 'await page.pdf({path: 'output.pdf', format: 'A4', printBackground: true, margin: {top: '20px', right: '20px', bottom: '20px', left: '20px'}})'. Options: format (A4, Letter, Legal), landscape: true, scale (0.1-2), pageRanges ('1-5, 8'), headerTemplate/footerTemplate (HTML with special classes), displayHeaderFooter: true. PDF generation only works in headless mode. For custom page size: width/height instead of format. Example invoice: load HTML, inject CSS for print media, call pdf(). Puppeteer PDFs are high quality - better than browser print or html2pdf libraries. Useful for reports, invoices, archiving."}]}
{"messages": [{"role": "user", "content": "How do I emulate different devices in Puppeteer?"}, {"role": "assistant", "content": "Use built-in device descriptors: 'const puppeteer = require('puppeteer'); const devices = puppeteer.devices; await page.emulate(devices['iPhone 12'])'. This sets: viewport, user agent, touch support, deviceScaleFactor. Available devices: iPhone models, iPad, Pixel phones, Galaxy phones, etc. Full list: puppeteer.devices. Manual emulation: 'await page.setViewport({width: 375, height: 667, isMobile: true, hasTouch: true, deviceScaleFactor: 2}); await page.setUserAgent('Mozilla/5.0 (iPhone...)');'. Also emulate geolocation, timezone, permissions. Useful for responsive design testing, mobile-specific scraping, bypassing desktop-only restrictions."}]}
{"messages": [{"role": "user", "content": "How can I handle file downloads in Puppeteer?"}, {"role": "assistant", "content": "Set download path via CDP: 'const client = await page.target().createCDPSession(); await client.send('Page.setDownloadBehavior', {behavior: 'allow', downloadPath: '/tmp/downloads'});'. Then click download link: 'await page.click('a[download]')'. Monitor for file: poll directory with fs.watch() or check file existence in loop. For download complete, check file size stabilizes. Alternative: intercept download request and fetch with node-fetch. For authenticated downloads, get cookies from page: 'const cookies = await page.cookies()', use in fetch headers. Headless downloads work - no need for visible browser. Clear download directory before each test."}]}
{"messages": [{"role": "user", "content": "What's the best way to debug Puppeteer scripts?"}, {"role": "assistant", "content": "Debug techniques: 1) Run non-headless: 'puppeteer.launch({headless: false, slowMo: 250})' to watch execution, 2) DevTools: 'puppeteer.launch({devtools: true})' opens Chrome DevTools, 3) Screenshots: 'await page.screenshot({path: 'debug.png'})' at failure points, 4) Console logs: 'page.on('console', msg => console.log('PAGE LOG:', msg.text()))', 5) Use debugger: 'await page.evaluate(() => {debugger;})' with devtools: true, 6) Verbose logging: 'DEBUG=puppeteer:* node script.js', 7) Try in real browser first, copy selectors. Common issues: selector timing (use waitForSelector), element not clickable (scroll into view), navigation timing (wait for networkidle)."}]}
{"messages": [{"role": "user", "content": "How do I handle CAPTCHA in Puppeteer automation?"}, {"role": "assistant", "content": "No legitimate automatic CAPTCHA solving. Options: 1) Test environment: disable CAPTCHA or use test key (reCAPTCHA has test keys), 2) Cookie reuse: login manually once, export cookies, load in automation to bypass login CAPTCHA, 3) CAPTCHA solving services: 2captcha, Anti-Captcha - send image/sitekey via API, get solution (costs money, against ToS), 4) Audio CAPTCHA + speech-to-text (unreliable), 5) Request developer to add automation-friendly auth for testing. Best: work with dev team to add CAPTCHA bypass for test accounts. Don't try to break production CAPTCHA - violates terms, wastes time. For testing, mock CAPTCHA response or use test mode."}]}
{"messages": [{"role": "user", "content": "How can I run Puppeteer in parallel for faster scraping?"}, {"role": "assistant", "content": "Launch multiple browser instances: 'const browsers = await Promise.all([puppeteer.launch(), puppeteer.launch(), puppeteer.launch()])'. Or use single browser with multiple pages: 'const browser = await puppeteer.launch(); const pages = await Promise.all([browser.newPage(), browser.newPage(), browser.newPage()])'. Process URLs in parallel: 'await Promise.all(urls.map(async url => { const page = await browser.newPage(); await page.goto(url); const data = await page.evaluate(...); await page.close(); return data; }))'. Limit concurrency to avoid overwhelming target or system: use p-limit library. For distributed: Puppeteer Cluster package handles pooling, queuing, retries. Be respectful: rate limiting, user-agent, robots.txt."}]}
{"messages": [{"role": "user", "content": "What's the difference between goto waitUntil options?"}, {"role": "assistant", "content": "page.goto() waitUntil options: 1) 'load' - wait for load event (DOMContentLoaded + resources), default, 2) 'domcontentloaded' - wait only for DOMContentLoaded (HTML parsed, doesn't wait for images/stylesheets), fastest, 3) 'networkidle0' - no network connections for 500ms, strictest, 4) 'networkidle2' - no more than 2 connections for 500ms, balanced. SPAs often need networkidle2 - AJAX calls after initial load. Use array for multiple: {waitUntil: ['load', 'networkidle2']}. For fast scraping: domcontentloaded + waitForSelector on specific element. For screenshots/PDFs: networkidle0 to ensure all resources loaded. Timeout default: 30s, increase for slow sites."}]}
{"messages": [{"role": "user", "content": "How do I handle alerts and dialogs in Puppeteer?"}, {"role": "assistant", "content": "Listen for dialog event: 'page.on('dialog', async dialog => { console.log(dialog.type(), dialog.message()); await dialog.accept('optional input for prompt'); })'. Must call accept() or dismiss(), otherwise script hangs. For confirm: 'await dialog.accept()' clicks OK, 'await dialog.dismiss()' clicks Cancel. For prompt: 'await dialog.accept('user input')'. For alert: 'await dialog.accept()'. Set listener before triggering dialog. Example: 'page.on('dialog', dialog => dialog.accept()); await page.click('button.trigger-alert');'. Unlike Selenium, Puppeteer requires event listener - no switchTo.alert(). Can also check dialog type: dialog.type() returns 'alert', 'confirm', 'prompt', or 'beforeunload'."}]}
{"messages": [{"role": "user", "content": "How can I execute code in Node.js context while scraping?"}, {"role": "assistant", "content": "Use page.evaluate() for browser context (can't access Node), regular async functions for Node context. Example: 'const data = await page.evaluate(() => document.title); // browser; await fs.writeFileSync('output.txt', data); // Node'. To pass data from Node to browser: 'await page.evaluate((nodeVar) => { console.log(nodeVar); }, valueFromNode)'. Can pass primitives, JSON-serializable objects, not functions or DOM elements. For complex data flow: expose Node functions to page: 'await page.exposeFunction('saveData', (data) => fs.writeFileSync('data.json', data)); await page.evaluate(async () => { await window.saveData({scraped: 'data'}); })'. Separate concerns: DOM manipulation in evaluate(), I/O in Node."}]}
{"messages": [{"role": "user", "content": "How do I handle iframes in Puppeteer?"}, {"role": "assistant", "content": "Access iframe: 'const frameHandle = await page.$('iframe[name=\"frameName\"]'); const frame = await frameHandle.contentFrame();'. Then interact: 'await frame.click('button'); const text = await frame.$eval('h1', el => el.textContent);'. Alternative: get frames by URL: 'const frame = page.frames().find(f => f.url().includes('iframe.html'))'. Or by name: 'const frame = page.frames().find(f => f.name() === 'frameName')'. Main frame: 'page.mainFrame()'. All frames: 'page.frames()'. Unlike Selenium, no need to 'switch' - each frame is object. For nested iframes: 'const childFrame = frame.childFrames()[0];'. Wait for frame: 'await page.waitForFrame(frame => frame.url().includes('target'))'. Cleaner API than Selenium's switch_to.frame()."}]}
{"messages": [{"role": "user", "content": "What are browser contexts and when should I use them?"}, {"role": "assistant", "content": "Browser contexts are isolated sessions within same browser instance - like incognito windows. Create: 'const context = await browser.createIncognitoBrowserContext(); const page = await context.newPage();'. Each context has separate cookies, storage, cache - isolated from others. Use cases: 1) Multi-account testing - each account in separate context, 2) Session isolation - prevent cookie leakage between tests, 3) Parallel scraping with different sessions, 4) A/B testing - different cookies/localStorage per context. More efficient than launching multiple browsers. Close context: 'await context.close()' closes all pages. Default context: browser.defaultBrowserContext() - not isolated. For real isolation, use incognito contexts. Puppeteer contexts â‰ˆ Selenium profiles, but lighter weight."}]}
{"messages": [{"role": "user", "content": "How can I monitor network traffic and API calls?"}, {"role": "assistant", "content": "Listen to request/response events: 'const apiCalls = []; page.on('response', async response => { if (response.url().includes('/api/')) { apiCalls.push({url: response.url(), status: response.status(), body: await response.json().catch(() => null)}); } });'. For requests: 'page.on('request', request => console.log(request.method(), request.url(), request.postData()))'. Filter by type: 'if (request.resourceType() === 'xhr')'. Modify: enable interception and change headers/data. For complete HAR files: use puppeteer-har package. Monitor performance: 'const metrics = await page.metrics(); const timing = JSON.parse(await page.evaluate(() => JSON.stringify(performance.timing)))'. Useful for: API reverse engineering, debugging, performance analysis, finding hidden endpoints."}]}
{"messages": [{"role": "user", "content": "How do I handle cookie consent popups automatically?"}, {"role": "assistant", "content": "Detect and click accept button: 'await page.waitForSelector('button[id*=\"accept\"], button[id*=\"consent\"], .cookie-accept', {timeout: 5000}).then(button => button.click()).catch(() => console.log('No cookie popup'))'. Use try/catch or timeout to handle pages without popups. Better: inject cookie before page load: 'await page.setCookie({name: 'cookie-consent', value: 'accepted', domain: '.example.com'}); await page.goto(url);'. Or block cookie consent scripts: 'page.on('request', req => req.url().includes('cookiebot') || req.url().includes('onetrust') ? req.abort() : req.continue())'. For common frameworks: create selector library for CookieBot, OneTrust, Quantcast, etc. Also consider I don't care about cookies extension via puppeteer-extra-plugin."}]}
{"messages": [{"role": "user", "content": "What's the best way to handle timeouts in Puppeteer?"}, {"role": "assistant", "content": "Set default timeout: 'page.setDefaultTimeout(60000)' or 'page.setDefaultNavigationTimeout(60000)' for navigation-specific. Per-operation timeout: 'await page.goto(url, {timeout: 10000})', 'await page.waitForSelector('div', {timeout: 5000})'. Disable timeout: {timeout: 0} - not recommended. Handle timeout errors: 'try { await page.waitForSelector('.element'); } catch (e) { if (e instanceof puppeteer.errors.TimeoutError) { console.log('Element did not appear'); } }'. Common causes: selector wrong, waitFor condition never met, slow network. Debug: increase timeout temporarily, check if element appears manually, use networkidle wait. Default: 30s for most operations. Production: use reasonable timeouts + retry logic."}]}
{"messages": [{"role": "user", "content": "How can I get console logs from the page in Puppeteer?"}, {"role": "assistant", "content": "Listen to console event: 'page.on('console', msg => { console.log('PAGE LOG:', msg.text(), msg.type()); for (let i = 0; i < msg.args().length; ++i) console.log(`Arg ${i}: ${msg.args()[i]}`); })'. msg.type() returns 'log', 'debug', 'info', 'error', 'warning'. Get JSHandle args: 'const args = await Promise.all(msg.args().map(arg => arg.jsonValue()))'. Useful for: debugging, capturing page errors, monitoring AJAX failures. Also listen to pageerror: 'page.on('pageerror', error => console.log('PAGE ERROR:', error.message))'. For network errors: page.on('requestfailed'). All page events: console, dialog, error, pageerror, request, response, requestfailed, requestfinished. Comprehensive logging helps debug scraping issues."}]}
{"messages": [{"role": "user", "content": "How do I interact with Shadow DOM in Puppeteer?"}, {"role": "assistant", "content": "Access shadow root: 'const host = await page.$('element-with-shadow'); const shadowRoot = await host.evaluateHandle(el => el.shadowRoot); const innerElement = await shadowRoot.$('.inside-shadow');'. Or use piercing selector: 'await page.evaluate(() => document.querySelector('host').shadowRoot.querySelector('.element').click())'. Puppeteer doesn't have built-in shadow DOM piercing like 'pierce/' or '>>>' (those are experimental). Best: use evaluate to traverse: 'await page.evaluate(() => { const host = document.querySelector('custom-element'); const button = host.shadowRoot.querySelector('button'); button.click(); })'. For deep nesting: traverse each shadowRoot. Libraries: query-selector-shadow-dom package for easier querying. Shadow DOM common in web components, Salesforce, Shopify admin."}]}
{"messages": [{"role": "user", "content": "How can I run Puppeteer on a server without display?"}, {"role": "assistant", "content": "Headless mode works on servers without X11: 'await puppeteer.launch({headless: true})' - no display needed. For older systems needing dependencies: install Chrome dependencies: 'apt-get install -y chromium-browser' or use puppeteer.launch({executablePath: '/usr/bin/chromium-browser'}). Docker: use official image 'buildkite/puppeteer' or install dependencies in Dockerfile. For minimal image: use puppeteer-core + chrome-aws-lambda (optimized for AWS Lambda). Required libs: ca-certificates, fonts-liberation, libappindicator3-1, libasound2, libatk-bridge2.0-0, etc. AWS Lambda: use chrome-aws-lambda package. Heroku: add buildpack heroku-buildpack-google-chrome. Headless is default in most environments - explicitly set for clarity."}]}
{"messages": [{"role": "user", "content": "How do I handle infinite loops or stuck pages in Puppeteer?"}, {"role": "assistant", "content": "Use timeouts aggressively: 'await page.goto(url, {timeout: 30000, waitUntil: 'domcontentloaded'})' instead of networkidle. Set max wait times: 'await page.waitForSelector('.element', {timeout: 10000}).catch(() => null)' returns null instead of throwing. For infinite scroll: set max iterations: 'for (let i = 0; i < 100 && stillScrolling; i++) {...}'. Detect stuck: if height not changing for N iterations, break. Handle with try/catch + fallback: 'try { await action(); } catch { await page.screenshot({path: 'stuck.png'}); await page.close(); }'. Use watchdog timers: wrap in Promise.race with timeout: 'await Promise.race([scrapePage(), timeout(60000)])'. Monitor: log progress, set overall script timeout. In production: implement retry with exponential backoff, circuit breaker pattern."}]}
