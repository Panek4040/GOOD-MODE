{"messages": [{"role": "user", "content": "What makes Playwright different from Puppeteer and Selenium?"}, {"role": "assistant", "content": "Playwright supports 3 browsers (Chromium, Firefox, WebKit) vs Puppeteer (Chrome only) and Selenium (multiple but slower). Key advantages: 1) Auto-wait - automatically waits for elements to be actionable, 2) Multiple contexts - isolated sessions in same browser, 3) Network interception built-in, 4) Trace viewer for debugging, 5) Better mobile emulation, 6) Video recording, 7) Modern API with locator strategy. Developed by Microsoft, similar API to Puppeteer but more powerful. Faster than Selenium, more reliable waits, better debugging tools. Best for modern web testing and cross-browser compatibility."}]}
{"messages": [{"role": "user", "content": "How does Playwright's auto-wait work?"}, {"role": "assistant", "content": "Playwright auto-waits before every action: before clicking, checks element is attached to DOM, visible, stable (not animating), enabled, receives events. No need for manual waits like Selenium. Example: 'await page.click('button')' automatically waits for button to be clickable. Checks: attached, visible, stable, enabled, not covered by other elements. Timeout default: 30s. Failed checks throw TimeoutError with details. Applies to: click, fill, select, check, uncheck, hover, etc. Can disable: {force: true} option. Makes tests more reliable - no flaky 'element not clickable' errors. Use explicit waits only for custom conditions: 'await page.locator('.item').waitFor({state: 'visible'})'."}]}
{"messages": [{"role": "user", "content": "What's the difference between page.locator() and page.$()?"}, {"role": "assistant", "content": "page.locator() is modern Playwright API - returns Locator (lazy, auto-waiting): 'const button = page.locator('button'); await button.click();'. Locators auto-retry until timeout, wait for actionability. page.$() is legacy ElementHandle API from Puppeteer - returns ElementHandle (snapshot, no auto-wait): 'const button = await page.$('button');'. ElementHandles don't auto-wait, can become stale. Recommendation: always use locator(). Benefits: auto-wait, strict mode (fails if multiple matches), better error messages, chainable: 'page.locator('.parent').locator('.child')'. Use $() only for complex evaluate scenarios. Locator = Playwright way, ElementHandle = legacy Puppeteer way."}]}
{"messages": [{"role": "user", "content": "How do I handle authentication across multiple tests?"}, {"role": "assistant", "content": "Use storageState to save/load authentication: 1) Login once and save state: 'await page.goto('login'); await page.fill('#email', 'user@test.com'); await page.fill('#password', 'pass'); await page.click('button'); await context.storageState({path: 'auth.json'});', 2) Reuse in tests: 'const context = await browser.newContext({storageState: 'auth.json'}); const page = await context.newPage();'. StorageState includes cookies, localStorage, sessionStorage. Much faster than logging in each test. For multiple users: save different state files (auth-admin.json, auth-user.json). Refresh state when session expires. Also works with beforeAll() in test frameworks for setup once, use many times pattern."}]}
{"messages": [{"role": "user", "content": "How can I run tests in parallel with Playwright?"}, {"role": "assistant", "content": "Playwright Test runner supports parallel by default: 'npx playwright test' runs in parallel workers. Configure in playwright.config.js: 'workers: 4' or 'workers: '50%''. Each worker gets isolated browser instance. For scripts without test runner: use Promise.all with multiple contexts: 'const contexts = await Promise.all([browser.newContext(), browser.newContext()]); const pages = await Promise.all(contexts.map(c => c.newPage())); await Promise.all(pages.map(p => p.goto(url)));'. Or p-limit for controlled concurrency. Contexts are lightweight - can run hundreds in single browser. Better than launching multiple browsers. Parallel + contexts = fast test execution."}]}
{"messages": [{"role": "user", "content": "How do I debug flaky tests in Playwright?"}, {"role": "assistant", "content": "Use trace viewer: 1) Record trace: 'await context.tracing.start({screenshots: true, snapshots: true}); ... await context.tracing.stop({path: 'trace.zip'});', 2) View: 'npx playwright show-trace trace.zip' shows timeline, screenshots, DOM snapshots, network, console. Other techniques: 1) Video recording: 'recordVideo: {dir: 'videos/'}' in context, 2) Screenshots on failure, 3) slowMo: delays actions for debugging: 'browser.launch({slowMo: 500})', 4) headed mode: 'headless: false', 5) Playwright Inspector: 'PWDEBUG=1 npx playwright test', 6) await page.pause() for breakpoints. Flaky causes: timing issues (use auto-wait), selectors (use getByRole), race conditions (use waitForLoadState). Trace viewer is best tool."}]}
{"messages": [{"role": "user", "content": "How can I mock API responses in Playwright?"}, {"role": "assistant", "content": "Use page.route() to intercept and mock: 'await page.route('**/api/users', route => route.fulfill({status: 200, contentType: 'application/json', body: JSON.stringify([{id: 1, name: 'Alice'}])}));'. Then normal page interactions use mocked data. For multiple endpoints: 'await page.route('**/api/**', route => { if (route.request().url().includes('/users')) route.fulfill({...}); else route.continue(); });'. Also: abort requests: 'route.abort()', modify requests: 'route.continue({headers: {...}})', add delays: 'setTimeout(() => route.fulfill(...), 2000)'. Useful for: testing error states, offline mode, slow networks, without backend. Better than test databases - faster, more controlled."}]}
{"messages": [{"role": "user", "content": "What are browser contexts and when should I use them?"}, {"role": "assistant", "content": "Browser contexts are isolated incognito-like sessions: separate cookies, storage, cache within same browser. Create: 'const context = await browser.newContext();'. Use cases: 1) Multi-user testing - different contexts for different users, 2) Parallel tests - each test gets own context, 3) Session isolation - prevent cookie leakage, 4) Different permissions/geolocation per context. Much lighter than launching browsers. One browser can have many contexts. Each context can have multiple pages (tabs). Example: 'const adminCtx = await browser.newContext({storageState: 'admin.json'}); const userCtx = await browser.newContext({storageState: 'user.json'});'. Close context to clear all data: 'await context.close();'. Contexts = cheap isolation."}]}
{"messages": [{"role": "user", "content": "How do I test across different browsers?"}, {"role": "assistant", "content": "Import all browser types: 'const { chromium, firefox, webkit } = require('playwright');'. Loop through: 'for (const browserType of [chromium, firefox, webkit]) { const browser = await browserType.launch(); const page = await browser.newPage(); await page.goto(url); // test... await browser.close(); }'. Or use Playwright Test config: 'projects: [{name: 'chromium', use: {browserName: 'chromium'}}, {name: 'firefox', use: {browserName: 'firefox'}}, {name: 'webkit', use: {browserName: 'webkit'}}]'. Then 'npx playwright test' runs on all. Check browser-specific behavior: 'if (browserType.name() === 'webkit') { ... }'. Playwright ensures API compatibility across browsers - same code works on all three. WebKit tests Safari behavior."}]}
{"messages": [{"role": "user", "content": "How can I handle iframes in Playwright?"}, {"role": "assistant", "content": "Use frameLocator() for modern approach: 'const frame = page.frameLocator('iframe[name=\"myframe\"]'); await frame.locator('button').click();'. FrameLocators are piercing - can chain into nested frames: 'page.frameLocator('.outer').frameLocator('.inner').locator('button')'. Legacy approach with frames(): 'const frame = page.frame({name: 'myframe'}); await frame.click('button');'. Wait for frame: 'const frame = await page.waitForFrame(frame => frame.url().includes('iframe.html'));'. Unlike Selenium, no 'switching' needed - locators work across frames. FrameLocator auto-waits like regular locators. For multiple frames: 'const frames = page.frames(); frames[1].click('button');'. Modern: always use frameLocator."}]}
{"messages": [{"role": "user", "content": "What's the best way to select elements in Playwright?"}, {"role": "assistant", "content": "Priority order (semantic to implementation): 1) getByRole: 'page.getByRole('button', {name: 'Submit'})' - most resilient, accessibility-friendly, 2) getByLabel: 'page.getByLabel('Email')' - for form fields, 3) getByPlaceholder: 'page.getByPlaceholder('Enter email')', 4) getByText: 'page.getByText('Click here')' - exact text, 5) getByTestId: 'page.getByTestId('submit-btn')' - requires data-testid attribute. Last resort: CSS/XPath: 'page.locator('button.submit')'. Roles: button, textbox, heading, link, etc. Combine: 'page.getByRole('dialog').getByRole('button', {name: 'Close'})'. Avoid: brittle selectors tied to styling. Role-based = tests work even after UI refactor."}]}
{"messages": [{"role": "user", "content": "How do I handle file uploads in Playwright?"}, {"role": "assistant", "content": "Use setInputFiles(): 'await page.locator('input[type=\"file\"]').setInputFiles('path/to/file.pdf');'. Multiple files: 'setInputFiles(['file1.pdf', 'file2.pdf'])'. Upload buffer: 'setInputFiles({name: 'test.txt', mimeType: 'text/plain', buffer: Buffer.from('content')})'. Remove files: 'setInputFiles([])'. For hidden inputs, no need to unhide - Playwright handles it. Listen to file chooser: 'const [fileChooser] = await Promise.all([page.waitForEvent('filechooser'), page.click('button.upload')]); await fileChooser.setFiles('file.pdf');'. Works even with drag-drop upload widgets. Playwright automatically waits for input to accept files. Simpler than Selenium - no need for sendKeys to invisible element."}]}
{"messages": [{"role": "user", "content": "How can I test mobile responsiveness?"}, {"role": "assistant", "content": "Use device descriptors: 'const { devices } = require('playwright'); const iPhone = devices['iPhone 12']; const context = await browser.newContext({...iPhone, geolocation: {latitude: 40.7128, longitude: -74.0060}, permissions: ['geolocation']});'. Sets viewport, user agent, touch events, deviceScaleFactor. Available devices: iPhone models, iPads, Pixels, Galaxy phones. List all: 'Object.keys(devices)'. Custom: 'await browser.newContext({viewport: {width: 375, height: 667}, isMobile: true, hasTouch: true});'. Also test: rotate screen (change viewport), hover vs touch, geolocation features. Check responsive: 'const width = await page.evaluate(() => window.innerWidth); expect(width).toBe(375);'. Test mobile-only features, touch gestures, different orientations."}]}
{"messages": [{"role": "user", "content": "How do I handle dialogs (alerts, confirms, prompts)?"}, {"role": "assistant", "content": "Listen for dialog event before triggering: 'page.once('dialog', async dialog => { console.log(dialog.message()); await dialog.accept('optional input'); });'. Then trigger: 'await page.click('button.show-alert');'. For all dialogs: 'page.on('dialog', ...)' (without 'once'). Actions: accept(), dismiss(), type (alert/confirm/prompt/beforeunload). Get text: dialog.message(). Accept with input (prompts): 'dialog.accept('user input')'. Default handler: auto-dismiss. If no handler set, dialogs auto-dismiss and test continues. Common pattern: set handler before click. Unlike Selenium, event-based - more reliable. Can also auto-accept all: 'page.on('dialog', d => d.accept());' at page creation."}]}
{"messages": [{"role": "user", "content": "How can I wait for network requests?"}, {"role": "assistant", "content": "Use waitForResponse(): 'const response = await page.waitForResponse('**/api/users'); const data = await response.json();'. Or waitForRequest(): 'const request = await page.waitForRequest('**/api/login');'. With predicate: 'await page.waitForResponse(res => res.url().includes('/api/') && res.status() === 200)'. Combined with action: 'const [response] = await Promise.all([page.waitForResponse('**/api/data'), page.click('button')]);'. For multiple requests: 'const responses = await Promise.all([page.waitForResponse('**/users'), page.waitForResponse('**/posts'), page.goto(url)]);'. Also: waitForLoadState('networkidle') waits until no requests for 500ms. Useful for SPA testing, verifying API calls, checking request data."}]}
{"messages": [{"role": "user", "content": "What are the different wait strategies in Playwright?"}, {"role": "assistant", "content": "LoadState options for page.goto() or waitForLoadState(): 1) 'load' - wait for load event (default for goto), 2) 'domcontentloaded' - HTML parsed, fastest, 3) 'networkidle' - no network activity for 500ms, strictest. Element waits via locators (automatic): attached, visible, stable, enabled. Explicit waits: waitFor({state: 'visible'}), waitFor({state: 'attached'}), waitFor({state: 'detached'}), waitFor({state: 'hidden'}). Other waits: waitForTimeout(ms) - not recommended, waitForFunction(() => condition), waitForURL(pattern), waitForResponse/Request. Best practice: rely on auto-wait from locators, use explicit waits only for custom conditions. Playwright auto-waits more intelligently than Selenium."}]}
{"messages": [{"role": "user", "content": "How do I take screenshots of specific elements?"}, {"role": "assistant", "content": "Use locator screenshot: 'await page.locator('div.card').screenshot({path: 'element.png'});'. Full page: 'await page.screenshot({fullPage: true, path: 'full.png'});'. Viewport only: 'await page.screenshot({path: 'viewport.png'});'. With mask: 'await page.screenshot({mask: [page.locator('.sensitive')], path: 'masked.png'});' hides sensitive data. Animation handling: 'screenshot({animations: 'disabled'})' for consistent visuals. Get buffer: 'const buffer = await page.screenshot();' for processing. Also: clip specific area: 'screenshot({clip: {x: 0, y: 0, width: 100, height: 100}})'. Combine with visual regression tools like Percy or Playwright's expect(page).toHaveScreenshot(). Element screenshots useful for component testing."}]}
{"messages": [{"role": "user", "content": "How can I test accessibility with Playwright?"}, {"role": "assistant", "content": "Use accessibility snapshot: 'const snapshot = await page.accessibility.snapshot(); console.log(snapshot);' returns accessibility tree. Check specific element: 'const snapshot = await page.locator('button').accessibility.snapshot();'. Integrate with @axe-core/playwright: 'const { injectAxe, checkA11y } = require('axe-playwright'); await injectAxe(page); const results = await checkA11y(page);'. Checks WCAG violations. Also: use getByRole for semantic selection - if elements can't be selected by role, accessibility issue. Test keyboard navigation: 'await page.keyboard.press('Tab'); const focused = await page.evaluate(() => document.activeElement.tagName);'. Check ARIA: 'await page.getByRole('button', {name: 'Submit'})' validates ARIA labels. Playwright's role-based selectors encourage accessible markup."}]}
{"messages": [{"role": "user", "content": "How do I retry failed tests?"}, {"role": "assistant", "content": "Playwright Test config: 'retries: 2' in playwright.config.js - retries failed tests up to 2 times. Or per-test: 'test.describe.configure({retries: 3});'. Programmatic retry: wrap in try/catch with loop: 'for (let i = 0; i < 3; i++) { try { await action(); break; } catch (e) { if (i === 2) throw e; } }'. Test runner shows attempt number: \"test (retry #2)\". View traces for all retries. Best practice: fix flaky tests instead of retrying. Common flaky causes: race conditions (use auto-wait), timing (use waitForLoadState), selectors (use getByRole). Retries mask problems - use sparingly. For CI: set retries: 1, locally: retries: 0 to find flakiness early."}]}
{"messages": [{"role": "user", "content": "How can I test drag and drop?"}, {"role": "assistant", "content": "Use dragTo(): 'await page.locator('#source').dragTo(page.locator('#target'));'. Playwright handles mousedown, mousemove, mouseup automatically. For precise control: 'const source = page.locator('#source'); const target = page.locator('#target'); await source.hover(); await page.mouse.down(); await target.hover(); await page.mouse.up();'. HTML5 drag: may need dataTransfer: 'await page.evaluate(() => { const src = document.querySelector('#source'); const tgt = document.querySelector('#target'); const dt = new DataTransfer(); src.dispatchEvent(new DragEvent('dragstart', {dataTransfer: dt})); tgt.dispatchEvent(new DragEvent('drop', {dataTransfer: dt})); });'. Simple dragTo() works for most cases. Test drag handles, reorderable lists, file uploads via drag."}]}
{"messages": [{"role": "user", "content": "How do I handle Shadow DOM?"}, {"role": "assistant", "content": "Playwright auto-pierces shadow DOM: 'await page.locator('custom-element button').click();' works even if button is in shadow root. No special syntax needed - just write selector as if no shadow boundary. For explicit access: 'const shadowHost = page.locator('custom-element'); const shadowButton = shadowHost.locator('button');'. Deep shadow roots: 'page.locator('outer-component inner-component button')'. This is major advantage over Selenium which requires manual shadow root traversal. Works with all selector strategies: role, text, CSS. Example: 'page.getByRole('button', {name: 'Submit'})' finds button even in closed shadow roots. Makes testing web components trivial. No evaluate() hacks needed."}]}
{"messages": [{"role": "user", "content": "How can I run tests in Docker?"}, {"role": "assistant", "content": "Use official Playwright image: 'FROM mcr.microsoft.com/playwright:v1.40.0-focal'. Dockerfile: 'FROM mcr.microsoft.com/playwright:v1.40.0-focal; WORKDIR /app; COPY package*.json ./; RUN npm ci; COPY . .; CMD [\"npx\", \"playwright\", \"test\"]'. Docker run: 'docker run -v $(pwd):/app -w /app mcr.microsoft.com/playwright:v1.40.0-focal npx playwright test'. Or docker-compose: 'services: playwright: image: mcr.microsoft.com/playwright:v1.40.0-focal volumes: - .:/app working_dir: /app command: npx playwright test'. Image includes all browsers, dependencies. For CI: use same image for consistent environment. Headless works without X11. Export artifacts: mount /app/test-results:/test-results volume."}]}
{"messages": [{"role": "user", "content": "What's the difference between expect() assertions in Playwright Test?"}, {"role": "assistant", "content": "Playwright Test has web-first assertions that auto-retry: 'await expect(page.locator('h1')).toHaveText('Expected');' retries until timeout. Web assertions: toBeVisible(), toBeHidden(), toBeEnabled(), toBeDisabled(), toHaveText(), toContainText(), toHaveValue(), toHaveAttribute(), toHaveCount(), toHaveCSS(), toHaveScreenshot(). Generic assertions (no retry): expect(value).toBe(), toEqual(), toContain() - for non-page values. Auto-retry prevents flaky tests - waits for condition. Configure timeout: 'await expect(locator).toBeVisible({timeout: 5000});'. Soft assertions: 'await expect.soft(locator).toHaveText('text');' - continues test on failure. Use web assertions for page state, generic for data validation. Auto-retry = major advantage."}]}
{"messages": [{"role": "user", "content": "How do I generate test code automatically?"}, {"role": "assistant", "content": "Use Playwright Codegen: 'npx playwright codegen https://example.com' opens browser, records actions as code. Generates: clicks, fills, navigations with proper waits. Output languages: JavaScript, Python, C#, Java. Save to file: 'npx playwright codegen --target javascript -o test.spec.js https://example.com'. With authentication: 'npx playwright codegen --save-storage=auth.json https://app.com' saves cookies. Load saved state: 'npx playwright codegen --load-storage=auth.json https://app.com'. Also: Inspector: 'PWDEBUG=1 npx playwright test' - step through existing tests, explore locators. Codegen good for quick scripts, learning API, getting selectors. Refine generated code - it's verbose. Use as starting point, not production code."}]}
{"messages": [{"role": "user", "content": "How can I test file downloads?"}, {"role": "assistant", "content": "Handle download event: 'const [download] = await Promise.all([page.waitForEvent('download'), page.click('a[download]')]); const path = await download.path(); console.log('Downloaded to:', path); await download.saveAs('/custom/path.pdf');'. Get filename: 'download.suggestedFilename()'. Wait for download: automatically waits. Check download: 'const stream = await download.createReadStream(); const content = await streamToString(stream);'. For authenticated downloads: cookies automatically included. Download URL: 'download.url()'. Delete after test: downloads auto-deleted unless saved with saveAs(). Works in all browsers including WebKit. No need for download directory config like Selenium - Playwright handles downloads elegantly in temp location."}]}
{"messages": [{"role": "user", "content": "How do I test hover actions?"}, {"role": "assistant", "content": "Use hover(): 'await page.locator('button').hover();'. Then check tooltip: 'await expect(page.locator('.tooltip')).toBeVisible();'. Hover is auto-waited - ensures element is actionable. Combined actions: 'await page.locator('.menu').hover(); await page.locator('.submenu-item').click();'. For multiple hovers: 'await page.locator('.item1').hover(); await page.locator('.item2').hover();'. Check CSS changes: 'await page.locator('button').hover(); await expect(page.locator('button')).toHaveCSS('background-color', 'rgb(0, 0, 255)');'. Force hover even if covered: 'await page.locator('button').hover({force: true});'. Works with touch devices too - Playwright handles differences. Test dropdown menus, tooltips, CSS :hover states."}]}
